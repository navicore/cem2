# Cem Standard Library Prelude
# Automatically included in every Cem program

# ==============================================================================
# Type Definitions
# ==============================================================================

type List(T)
  | Cons(T, List(T))
  | Nil

type Option(T)
  | Some(T)
  | None

# ==============================================================================
# List Operations
# ==============================================================================

# list-empty: Create an empty list
# ( -- List(T) )
: list-empty ( -- List(T) )
  Nil ;

# list-cons: Add element to front of list
# ( T List(T) -- List(T) )
: list-cons ( T List(T) -- List(T) )
  Cons ;

# list-head: Get first element of list (unsafe - crashes on empty list)
# ( List(T) -- T )
: list-head ( List(T) -- T )
  match
    Cons => [ swap drop ]  # ( head tail -- head )
    Nil  => [ "list-head: empty list" write_line 1 exit ]
  end ;

# list-tail: Get rest of list (unsafe - crashes on empty list)
# ( List(T) -- List(T) )
: list-tail ( List(T) -- List(T) )
  match
    Cons => [ drop ]       # ( head tail -- tail )
    Nil  => [ "list-tail: empty list" write_line 1 exit ]
  end ;

# list-head-safe: Get first element of list safely
# ( List(T) -- Option(T) )
: list-head-safe ( List(T) -- Option(T) )
  match
    Cons => [ swap drop Some ]  # ( head tail -- Some(head) )
    Nil  => [ None ]
  end ;

# list-tail-safe: Get rest of list safely
# ( List(T) -- Option(List(T)) )
: list-tail-safe ( List(T) -- Option(List(T)) )
  match
    Cons => [ drop Some ]       # ( head tail -- Some(tail) )
    Nil  => [ None ]
  end ;

# list-is-empty: Check if list is empty
# ( List(T) -- Bool )
: list-is-empty ( List(T) -- Bool )
  match
    Cons => [ drop drop false ]  # Drop both head and tail, return false
    Nil  => [ true ]
  end ;

# list-length-helper: Tail-recursive helper for list-length
# ( List(T) Int -- Int )
: list-length-helper ( List(T) Int -- Int )
  swap                      # ( count list )
  match
    Cons => [               # ( count head tail )
      swap drop             # ( count tail ) - drop head
      swap 1 +              # ( tail count+1 )
      list-length-helper    # Recurse: ( tail count+1 )
    ]
    Nil => [ ]              # ( count ) - return accumulator
  end ;

# list-length: Get length of list (tail-recursive, safe for large lists)
# ( List(T) -- Int )
: list-length ( List(T) -- Int )
  0                         # ( list 0 )
  list-length-helper ;

# list-reverse-helper: Helper for list-reverse (accumulator-based)
# ( List(T) List(T) -- List(T) )
: list-reverse-helper ( List(T) List(T) -- List(T) )
  swap                      # ( acc list )
  match
    Cons => [               # ( acc head tail )
      rot swap              # ( head acc tail )
      rot                   # ( acc tail head )
      rot                   # ( tail head acc )
      swap Cons             # ( tail head::acc )
      list-reverse-helper   # Recurse with tail and new acc
    ]
    Nil => [ ]              # ( acc ) - return accumulator
  end ;

# list-reverse: Reverse a list
# ( List(T) -- List(T) )
: list-reverse ( List(T) -- List(T) )
  Nil                       # Empty accumulator
  list-reverse-helper ;

# list-append: Append two lists
# ( List(T) List(T) -- List(T) )
: list-append ( List(T) List(T) -- List(T) )
  swap                      # ( list2 list1 )
  match
    Cons => [               # ( list2 head tail )
      rot                   # ( head tail list2 )
      list-append           # ( head tail++list2 )
      Cons                  # ( head::(tail++list2) )
    ]
    Nil => [ ]              # ( list2 ) - return list2
  end ;



# ==============================================================================
# Quotation Operations
# ==============================================================================

# call: Invoke a quotation (alias for call_quotation)
# ( [A -- B] -- )
: call ( [A -- B] -- )
  call_quotation ;

# ==============================================================================
# Higher-Order List Operations
# ==============================================================================

# list-map-helper: Recursive helper for list-map
# ( list func acc -- result )
: list-map-helper ( List(T) [T -- U] List(U) -- List(U) )
  rot               # ( func acc list )
  match
    Cons => [       # ( func acc head tail )
      # Goal: Apply func to head, cons result to acc, recurse on tail
      # For recursion we need: ( tail func new_acc )

      # Step 1: Duplicate func and position it to call on head
      swap rot      # ( func head tail acc )
      rot           # ( func tail acc head )
      swap rot      # ( func tail head acc )
      swap          # ( func tail acc head )
      rot rot       # ( tail acc func head )
      over          # ( tail acc func head func )
      swap          # ( tail acc func func head )
      swap          # ( tail acc func head func )
      call          # ( tail acc func result )

      # Step 2: Cons result to acc
      swap rot      # ( tail func acc result )
      swap Cons     # ( tail func result::acc )

      # Step 3: Recurse
      list-map-helper
    ]
    Nil => [        # ( func acc )
      swap drop     # ( acc ) - drop function
      list-reverse  # Reverse to restore order
    ]
  end ;

# list-map: Transform each element of a list using a function
# ( List(T) [T -- U] -- List(U) )
: list-map ( List(T) [T -- U] -- List(U) )
  Nil               # ( list func Nil )
  list-map-helper ;

# list-filter: Select elements matching a predicate
# ( List(T) [T -- Bool] -- List(T) )
: list-filter ( List(T) [T -- Bool] -- List(T) )
  Nil swap          # ( list pred Nil ) - empty accumulator
  rot               # ( pred acc list )
  match
    Cons => [       # ( pred acc head tail )
      rot rot       # ( acc head pred tail )
      swap over     # ( acc head tail pred pred )
      rot rot       # ( acc pred tail pred head )
      swap dup      # ( acc pred tail head head pred )
      rot call      # ( acc pred tail head keep? )
      if
        [ # Keep this element  - ( acc pred tail head )
          rot swap  # ( pred tail acc head )
          swap Cons # ( pred tail head::acc )
        ]
        [ # Skip this element
          drop      # ( acc pred tail )
          rot       # ( pred tail acc )
        ]
      list-filter   # Recurse
    ]
    Nil => [        # ( pred acc )
      swap drop     # ( acc ) - drop predicate
      list-reverse  # Reverse to restore order
    ]
  end ;

# list-fold-left: Fold list from left to right
# Example: [1,2,3] 0 [+] -> ((0+1)+2)+3 = 6
# ( List(T) U [U T -- U] -- U )
: list-fold-left ( List(T) U [U T -- U] -- U )
  rot               # ( acc f list )
  match
    Cons => [       # ( acc f head tail )
      swap rot      # ( acc head f tail )
      swap rot      # ( acc f head tail )
      rot rot       # ( f head acc tail )
      swap over     # ( f head tail acc f )
      rot rot       # ( f acc f head tail )
      swap call     # ( f acc tail new_acc )
      swap          # ( f new_acc acc tail )
      drop          # ( f new_acc tail )
      swap          # ( f tail new_acc )
      rot           # ( tail new_acc f )
      swap          # ( tail f new_acc )
      list-fold-left # Recurse
    ]
    Nil => [        # ( acc f )
      drop          # ( acc ) - drop function
    ]
  end ;
